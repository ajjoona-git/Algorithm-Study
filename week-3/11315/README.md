# 11315: 오목 판정 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AXaSUPYqPYMDFASQ&probBoxId=AZh3fFV6jffHBINp&type=PROBLEM&problemBoxTitle=8%EC%9B%94+2%EC%A3%BC%EC%B0%A8%288%EC%9B%94+18%EC%9D%BC%EA%B9%8C%EC%A7%80+%ED%91%B8%EC%8B%9C%EC%98%A4%29&problemBoxCnt=8)

## 💡 접근 방식 1: 델타 (PASS)

### 1. 사용 알고리즘
* **구현(Implementation)**
* **2차원 배열 순회** 및 **방향 벡터(Delta Array)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 오목판의 크기 `N`과 `'o'` 또는 `'.'` 문자로 구성된 `N x N` 크기의 `grid`를 입력받습니다.
2.  오목을 판정하기 위해 가로, 세로, 우상향 대각선, 우하향 대각선의 4가지 방향을 탐색하기 위한 델타 배열을 정의합니다.
3.  이중 반복문을 사용하여 `grid` 배열의 모든 위치 `(r, c)`를 순회하며 `'o'`가 있는 지점을 찾습니다.
4.  `'o'`를 찾으면, 4가지 방향 각각에 대해 5개의 돌이 연속으로 놓여있는지 확인합니다.
5.  `for k in range(1, 5)` 반복문을 통해 현재 위치에서 `1`칸부터 `4`칸까지 떨어진 위치를 탐색합니다.
6.  탐색한 위치가 배열의 경계를 벗어나지 않고, 그 위치에 `'o'`가 있는지 확인합니다.
7.  만약 5개의 돌이 연속으로 발견되면, 오목이 성립하므로 `"YES"`를 즉시 반환하고 탐색을 종료합니다.
8.  모든 돌에 대한 모든 방향의 탐색이 끝날 때까지 오목을 발견하지 못했다면, `"NO"`를 반환합니다.
9.  최종 결과를 테스트 케이스 번호와 함께 출력 형식에 맞춰 출력합니다.

---

## 💻 코드
* [11315v2.py](11315v2.py)


---

### 💡 접근 방식 2: 배열 순회 (FAIL)

### 1. 사용 알고리즘
* **구현(Implementation)**
* **2차원 배열 순회** 및 **상태 관리**

### 2. 문제 풀이 과정
1.  먼저 오목판의 크기 `N`과 `N x N` 크기의 `grid`를 입력받습니다.
2.  가로, 세로, 두 대각선 방향으로 연속된 `'o'`의 개수를 확인하는 함수 `check_bingo()`를 정의합니다.
3.  **가로줄 검사**: 이중 반복문을 사용하여 각 행을 순회하며 연속된 `'o'`의 개수를 `count` 변수로 셉니다. `'o'`가 아닌 문자를 만나거나 행의 끝에 도달하면 `count`가 5 이상인지 확인하여 `"YES"`를 반환합니다.
4.  **세로줄 검사**: 가로줄 검사와 동일한 방식으로 각 열을 순회하며 연속된 `'o'`의 개수를 셉니다.
5.  **대각선 검사**: 두 개의 주요 대각선(`/`, `\`)을 순회하며 연속된 `'o'`의 개수를 확인합니다.
6.  이 코드에서는 가로, 세로, 대각선 중 하나라도 오목이 완성되면 `"YES"`를 즉시 반환하고, 모든 검사를 마쳤을 때 오목이 발견되지 않으면 `"NO"`를 반환합니다.

---

### 3. 연산 시간이 오래 걸리는 이유 및 오류 분석
이 코드는 가로, 세로 검사 로직은 올바르지만, **대각선 검사 로직에 오류가 있어 모든 가능한 대각선 오목을 판별하지 못합니다.** 중앙을 가로지르는 두 대각선만 검사하고, 다른 위치에서 시작하는 대각선들은 고려하지 않았기 때문에 93/100점의 결과가 나온 것으로 보입니다.

---
## 💻 코드
* [11315.py](11315.py)