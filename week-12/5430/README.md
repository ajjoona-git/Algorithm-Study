# 5430. AC | 골드5

## 문제 출처
[BOJ](https://www.acmicpc.net/problem/5430)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **투 포인터 (Two Pointers)**
* **전처리 (Preprocessing)**

### 2. 문제 풀이 과정
1.  `R` (뒤집기) 연산을 매번 수행하면 **시간 초과**가 발생하므로, 실제 배열은 그대로 두고 **`left`**와 **`right`** 투 포인터를 사용하여 유효한 데이터의 범위를 추적합니다.
2.  본격적인 연산 전에 함수 `p`에 대해 불필요한 연산을 줄이는 **전처리**를 수행합니다.
    * `D` (삭제)의 개수가 배열의 길이 `n`보다 크면 즉시 "error"를 출력합니다.
    * `RR` (연속 뒤집기)은 상태를 원상 복구하므로, `replace("RR", "")`를 통해 모두 제거합니다.
3.  `left`는 0, `right`는 `n-1` (배열의 마지막 인덱스)로 초기화합니다.
4.  `p`를 순회하며 `R`을 만나면, `left`와 `right` 포인터의 값을 **서로 스왑**하여 탐색 방향(정방향/역방향)을 바꿉니다.
5.  `D`를 만나면, 현재 방향에 따라 유효 범위의 시작점을 한 칸 이동시킵니다.
    * 정방향 (`left <= right`)일 때: `left += 1`
    * 역방향 (`left > right`)일 때: `left -= 1`
6.  모든 연산이 끝난 후, `left`와 `right`의 최종 위치와 방향(정방향/역방향)을 기준으로 배열을 **슬라이싱**하여 결과를 출력합니다.

---

## 💡 접근 방식 2

### 1. 사용 알고리즘
* **투 포인터 (Two Pointers)**
* **플래그 (Flag) 변수**

### 2. 문제 풀이 과정
1.  `R` 연산 시 실제 배열을 뒤집는 대신, `is_reversed` **플래그 변수**를 사용하여 현재 배열의 탐색 방향(정방향/역방향)을 추적합니다.
2.  `left`와 `right` **투 포인터**를 사용하여 배열의 유효한 범위를 **반개방 구간 `[left, right)`**로 관리합니다. (`left=0`, `right=n`으로 시작)
3.  `D`의 개수가 `n`보다 많으면 "error" 처리, `RR`은 제거하는 **전처리**를 수행합니다.
4.  함수 `p`를 순회하며 `R`을 만나면 `is_reversed` 플래그의 값을 토글합니다.
5.  `D`를 만나면, `is_reversed` 플래그 값에 따라 유효 범위를 좁힙니다.
    * 정방향 (`not is_reversed`): `left += 1` (왼쪽에서 첫 번째 원소 제거)
    * 역방향 (`is_reversed`): `right -= 1` (오른쪽에서 첫 번째 원소 제거)
6.  배열이 비어있을 때(`left == right`) `D` 연산을 시도하면, `is_error` 플래그를 `True`로 설정하고 즉시 중단합니다.
7.  모든 연산이 끝난 후, `arr[left:right]`로 최종 유효 범위를 슬라이싱합니다.
8.  만약 `is_reversed`가 `True`라면, 슬라이싱한 결과 배열을 **마지막에 한 번만 뒤집어**(`result.reverse()`) 최종 결과를 출력합니다.

---

## 💻 코드
* [5430.py](5430.py)
* [5430v2.py](5430v2.py)