# 9251. LCS | 골드5

## 문제 출처
[BOJ](https://www.acmicpc.net/problem/9251)

## 💡 접근 방식 1 (FAIL)

### 1. 사용 알고리즘
* **브루트포스(Brute-Force)**
* **투 포인터(Two Pointers)** (혹은 **그리디(Greedy)**)

### 2. 문제 풀이 과정
1.  두 문자열 `line1`과 `line2`를 입력받습니다.
2.  `find_lcs` 함수는 `line1`을 기준으로 `line2`를 순회하며 공통 부분 수열을 찾는 로직입니다.
3.  `line1`의 모든 인덱스(`start`)를 공통 부분 수열의 시작점이 될 가능성으로 보고 순회합니다. (N)
4.  `start` 인덱스부터 `line1`의 끝까지(`pointer1`) 순회하며, `line2`에서 해당 문자를 찾기 위해 `pointer2`를 이동시킵니다. (N * M)
5.  `line1[pointer1]`과 `line2[pointer2]`가 일치하면 길이를 1 증가시키고, `pointer2`도 다음 칸으로 이동합니다.
6.  일치하는 문자를 찾지 못하고 `line2`의 끝에 도달하면, `pointer2`를 이전 위치로 "백트래킹" 시키려고 시도합니다. (이 부분이 LCS의 올바른 로직이 아님)
7.  `find_lcs(str1, str2)`와 `find_lcs(str2, str1)`을 각각 호출하여, 기준 문자열을 바꾸어 두 번 실행한 뒤 최대 길이를 출력합니다.

## 💡 오류 분석 및 해결

### 1. 문제 원인
* **로직 오류 (오답):** 코드 주석에 언급된 대로, 현재의 **그리디(Greedy)** 방식은 최장 공통 부분 수열을 보장하지 못합니다. (예: `VREGDFELK` / `VLSKD`에 대해 `VD`를 찾지만 정답은 `VLK`). LCS는 현재 문자가 일치하지 않을 때, (1) `line1`의 다음 문자와 비교, (2) `line2`의 다음 문자와 비교 중 더 긴 경우를 선택해야 하는 **최적 부분 구조**를 가지는데, 이 코드는 이를 고려하지 않고 `line1`의 다음 문자로만 넘어갑니다.
* **시간 복잡도 (시간 초과):** `find_lcs` 함수는 `start` 루프(O(N)), `pointer1` 루프(O(N)), `pointer2`를 찾는 `while` 루프(O(M))가 중첩되는 구조입니다. 최악의 경우 **O(N² * M)** 또는 **O(N³) (N=M일 때)**의 시간 복잡도를 가지므로, 문자열 길이(1000)에 대해 2초의 시간 제한을 반드시 초과합니다.

### 2. 해결 방법
* 이 문제는 **다이나믹 프로그래밍 (Dynamic Programming)**을 사용하여 해결해야 합니다.
* `dp[i][j]`를 `str1`의 `i`번째 문자까지와 `str2`의 `j`번째 문자까지의 LCS 길이라고 정의하는 2차원 DP 테이블을 생성합니다.
* 점화식은 다음과 같습니다:
    * `str1[i] == str2[j]`인 경우: `dp[i][j] = dp[i-1][j-1] + 1`
    * `str1[i] != str2[j]`인 경우: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
* 이 방식을 사용하면 **O(N*M)**의 시간 복잡도로 문제를 해결할 수 있습니다.

## 💻 코드
* [9251.py](9251.py)

---

## 💡 접근 방식 2 (PASS)

### 1. 사용 알고리즘
* **다이나믹 프로그래밍 (Dynamic Programming)**

### 2. 문제 풀이 과정
1.  **최장 공통 부분 수열 (LCS)**을 찾는 DP로 모델링합니다.
2.  `dp[i][j]`를 `str1`의 `i`번째 문자까지와 `str2`의 `j`번째 문자까지의 LCS 최대 길이로 정의합니다.
3.  두 문자열의 길이를 `n1`, `n2`라고 할 때, `(n1 + 1) x (n2 + 1)` 크기의 2차원 **DP 테이블**(`dp`)을 0으로 초기화합니다.
4.  2중 반복문을 사용하여 `dp` 테이블을 1행 1열부터 순차적으로 채웁니다 (`i`는 1부터 `n1`까지, `j`는 1부터 `n2`까지).
5.  **점화식**을 적용합니다:
    * `str1[i-1]`과 `str2[j-1]` (각 문자열의 `i`번째, `j`번째 문자)이 같다면, 두 문자가 LCS에 포함되므로 이전 대각선 값(`dp[i-1][j-1]`)에 1을 더합니다.
    * 두 문자가 다르다면, LCS는 (1) `str1`의 `i`번째 문자를 제외한 경우(`dp[i-1][j]`) 또는 (2) `str2`의 `j`번째 문자를 제외한 경우(`dp[i][j-1]`) 중 더 큰 값을 따릅니다.
6.  테이블을 모두 채운 후, `dp[n1][n2]` (테이블의 가장 오른쪽 아래 값)이 두 문자열 전체의 LCS 길이가 되므로 이를 출력합니다.

## 💻 코드
* [9251v2.py](9251v2.py)