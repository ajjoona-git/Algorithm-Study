# 2383. 점심 식사시간

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AV5-BEE6AK0DFAVl&probBoxId=AZlxYsXq_crHBITM&type=PROBLEM&problemBoxTitle=9%EC%9B%94+4%EC%A3%BC%EC%B0%A8%289%2F28%EA%B9%8C%EC%A7%80+%ED%91%B8%EC%8B%9C%EC%98%A4%29&problemBoxCnt=2)

## 💡 접근 방식

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search) / 조합 (Combinations)**
* **DFS & 백트래킹 (Backtracking)**
* **시뮬레이션 (Simulation)**
* **우선순위 큐 (Priority Queue) / 힙 (Heap)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 각 사람이 1번 계단 또는 2번 계단 중 어느 쪽으로 갈지 결정하는 모든 경우의 수를 탐색해야 하는 **완전 탐색** 문제입니다. `N`명의 사람에 대해 `2^N`가지의 조합이 존재합니다.
2.  **모든 조합 생성 (`generate_combines` 함수)**:
    * **DFS와 백트래킹**을 사용하는 재귀 함수를 통해, 각 사람을 1번 계단 그룹 또는 2번 계단 그룹에 배정하는 모든 경우의 수를 생성합니다.
    * 모든 사람에 대한 배정이 완료되면(재귀의 종료 조건), 각 계단 그룹에 대해 시뮬레이션을 실행하여 최종 소요 시간을 계산합니다.
3.  **계단 내려가기 시뮬레이션 (`calculate_time` 함수)**:
    * 특정 계단에 배정된 사람들의 그룹(`picked`)에 대해, 마지막 사람이 계단을 모두 내려가는 시간을 계산합니다.
    * **(1) 도착 시간 정렬**: 먼저, 그룹 내 모든 사람이 각자 계단 입구까지 도착하는 시간(거리)을 계산하고 오름차순으로 정렬합니다.
    * **(2) 우선순위 큐 활용**: 계단을 현재 내려가고 있는 사람(최대 3명)들의 **내려가기가 끝나는 시각**을 **우선순위 큐(최소 힙)**에 저장하여 관리합니다. 이를 통해 현재 계단에 있는 사람 중 가장 빨리 나오는 사람을 효율적으로 알 수 있습니다.
    * **(3) 대기 시간 계산**: 정렬된 순서대로 각 사람이 계단을 내려가기 시작하는 시간을 계산합니다.
        * 만약 계단에 3명 미만이 있다면, `(도착 시간 + 1)`에 바로 내려가기 시작합니다.
        * 만약 계단이 꽉 차 있다면, `(도착 시간 + 1)`과 `(계단에서 가장 빨리 나오는 사람의 완료 시각)` 중 더 늦은 시간에 내려가기 시작합니다.
    * **(4) 최종 시간**: 그룹의 모든 사람이 계단을 내려간 후, 우선순위 큐에 남아있는 가장 늦은 완료 시각이 해당 그룹의 소요 시간이 됩니다.
4.  **최소 시간 갱신**:
    * 1번 계단 그룹의 소요 시간과 2번 계단 그룹의 소요 시간 중 더 오래 걸리는 시간(`max(time_A, time_B)`)이 해당 조합의 최종 소요 시간입니다.
    * 이 값을 전역 변수 `min_time`과 비교하여 최소값을 갱신합니다. 모든 조합을 탐색한 후 `min_time`이 최종 결과가 됩니다.


## 💡 오류 분석 및 해결

### 1. 문제 원인
* 주석에 언급된 것처럼, 이 문제는 단순한 **그리디(Greedy) 방식**으로 접근할 경우 오답이 발생합니다.
* **실패 예시**: '각 사람을 가장 가까운 계단으로 보낸다'는 전략은 최적해를 보장하지 않습니다. 만약 많은 사람이 가까운 계단으로 한꺼번에 몰릴 경우, 긴 대기 시간으로 인해 오히려 총 소요 시간이 늘어날 수 있습니다. 한 사람의 최적 선택이 다른 사람들에게 악영향을 미쳐 전체적으로는 비효율적인 결과를 낳을 수 있습니다.
* 각 사람의 선택이 서로에게 영향을 미치기 때문에, 모든 사람의 배정 상태를 종합적으로 고려해야만 최적해를 찾을 수 있습니다.

### 2. 해결 방법
* 위와 같은 이유로, 모든 가능한 배정 조합을 탐색하는 **완전 탐색**이 필요합니다.
* 최종 코드는 재귀 함수를 이용해 각 사람을 두 계단 중 하나에 배정하는 모든 `2^M`가지 경우의 수를 생성합니다.
* 각각의 경우의 수에 대해, 상세한 시뮬레이션(`calculate_time`)을 통해 정확한 소요 시간을 계산하고 그중 최솟값을 찾는 방식으로 문제를 해결합니다. 이 접근법은 모든 가능성을 고려하므로 반드시 정답을 찾을 수 있습니다.


---

## 💻 코드
* [2383.py](2383.py)