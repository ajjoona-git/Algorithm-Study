# 4013. 특이한 자석

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?contestProbId=AWIeV9sKkcoDFAVH&solveclubId=AZgvQCv6GNXHBIT9&problemBoxTitle=9%EC%9B%94+4%EC%A3%BC%EC%B0%A8%289%2F28%EA%B9%8C%EC%A7%80+%ED%91%B8%EC%8B%9C%EC%98%A4%29&problemBoxCnt=2&probBoxId=AZlxYsXq_crHBITM)

## 💡 접근 방식

### 1. 사용 알고리즘
* **구현 (Implementation)**
* **시뮬레이션 (Simulation)**
* **데크 (deque)**

### 2. 문제 풀이 과정
1.  [문제에 대한 간략한 모델링 또는 핵심 아이디어를 설명합니다.]
    * 4개의 자석이 연쇄적으로 회전하는 과정을 시뮬레이션하는 문제입니다.
    * 8개의 날을 가진 각 자석의 회전은 원형 큐의 동작과 같으므로, `rotate()` 메소드를 효율적으로 사용할 수 있는 **데크(deque)** 자료구조로 각 자석을 표현합니다.

2.  [코드의 첫 번째 주요 단계에 대한 설명을 작성합니다.]
    * **연쇄 회전 조건 사전 계산**: 한 자석의 회전이 옆 자석에 영향을 미칠지 여부는 **회전이 일어나기 전의 상태**에 의해 결정됩니다. 따라서, 특정 자석을 회전시키기 전에 `is_attracted()` 함수를 호출하여 모든 인접한 자석들(0-1번, 1-2번, 2-3번)의 맞닿은 날이 서로 다른 극인지 미리 계산하여 `attracted` 리스트에 저장해 둡니다.

3.  [코드의 두 번째 주요 단계에 대한 설명을 작성합니다.]
    * **회전 시뮬레이션 (`rotate_magnetic` 함수)**:
        * **1. 지정된 자석 회전**: 먼저, 명령으로 주어진 자석(`mag_idx`)을 지정된 방향(`dir`)으로 회전시킵니다.
        * **2. 오른쪽으로 전파**: 지정된 자석부터 오른쪽으로(`mag_idx`, `mag_idx + 1`, ...) 이동하며, **사전 계산된 `attracted` 리스트**를 확인합니다. 만약 `i`번과 `i+1`번 자석이 서로 다른 극이라 회전 조건이 된다면, `i+1`번 자석을 반대 방향으로 회전시킵니다. 이 과정은 회전 조건이 안 되는 자석을 만날 때까지 반복합니다.
        * **3. 왼쪽으로 전파**: 동일한 방식으로, 지정된 자석부터 왼쪽으로 이동하며 사전 계산된 `attracted` 정보를 바탕으로 연쇄 회전을 시뮬레이션합니다.

4.  [...코드의 논리적 흐름에 따라 필요한 만큼 단계를 추가합니다.]
    * **전체 시뮬레이션 실행**: 총 K번의 회전 명령을 `for` 루프를 통해 순서대로 처리하며, 매번 `rotate_magnetic` 함수를 호출하여 4개 자석의 최종 상태를 결정합니다.

5.  [최종 결과를 도출하는 과정을 설명하며 마무리합니다.]
    * **점수 계산**: K번의 회전이 모두 끝난 후, 각 자석의 12시 방향(인덱스 0) 날이 S극(1)인 경우에만 정해진 점수(1, 2, 4, 8)를 합산하여 최종 점수를 계산하고 출력합니다.


---

## 💻 코드
* [4013.py](4013.py)