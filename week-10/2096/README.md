# 2096. 내려가기 | 골드5

## 문제 출처
[BOJ](https://www.acmicpc.net/problem/2096)

## 💡 접근 방식 1 (FAIL)

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search) / 깊이 우선 탐색 (DFS)**
* **동적 계획법 (Dynamic Programming) / 메모이제이션 (시도)**

### 2. 문제 풀이 과정
1.  [문제에 대한 간략한 모델링 또는 핵심 아이디어를 설명합니다.]
    * `(0, c)`에서 `(N-1, c)`까지 아래, 왼쪽 아래, 오른쪽 아래로만 이동하며 만들 수 있는 모든 경로를 탐색하여 최대/최소 점수를 찾는 문제입니다.

2.  [코드의 첫 번째 주요 단계에 대한 설명을 작성합니다.]
    * `dp[N][3][2]` 크기의 3차원 배열을 생성하여, 각 `(r, c)` 지점에 도달할 수 있는 최대 점수와 최소 점수를 기록하려고 시도했습니다.

3.  [코드의 두 번째 주요 단계에 대한 설명을 작성합니다.]
    * `calculate_score_recur` (재귀 DFS) 또는 `calculate_score_stack` (스택 DFS) 함수를 사용해, 첫 번째 행의 각 칸에서 출발하는 모든 가능한 경로를 **완전 탐색**합니다.

4.  [...코드의 논리적 흐름에 따라 필요한 만큼 단계를 추가합니다.]
    * 탐색(DFS)을 진행하면서, `(r, c)` 지점에 도달했을 때의 누적 점수가 `dp[r][c]`에 저장된 값보다 더 좋으면 갱신합니다.

5.  [최종 결과를 도출하는 과정을 설명하며 마무리합니다.]
    * 모든 탐색이 완료된 후, `dp` 배열의 마지막 행(`dp[N-1]`)에 기록된 값들 중 가장 큰 값과 가장 작은 값을 찾아 출력합니다.

## 💡 오류 분석 및 해결

### 1. 문제 원인
* **메모리 초과 (Memory Limit Exceeded)**: 주석에서 언급하신 대로, 이 코드의 가장 치명적인 문제는 **메모리 초과**입니다.
* **원인**: 문제의 **메모리 제한은 4MB**로 극도로 엄격합니다. 하지만 코드에서는 `N`개의 행에 대한 정보를 모두 저장하는 3차원 배열 `dp = [[[...]*3]*N]`을 생성합니다.
* `N`의 최대 범위가 100,000이므로, 이 배열의 크기는 `100,000(N) * 3(열) * 2(최대/최소)` 만큼의 공간을 필요로 합니다. 이는 Python의 정수 객체 크기를 고려할 때 4MB 제한을 수십 배 초과하게 되어 메모리 초과가 발생합니다.
* 또한, 재귀나 스택을 이용한 DFS 방식은 $O(3^N)$에 가까운 시간 복잡도를 가져, 메모리 문제와 별개로 **시간 초과**도 함께 발생할 가능성이 높습니다.

### 2. 해결 방법
* **$O(1)$ 공간 복잡도의 동적 계획법(DP)**: 이 문제는 **동적 계획법(DP)**으로 해결해야 하며, 특히 메모리 제한을 맞추기 위해 공간 최적화가 필수적입니다.
* **핵심 아이디어**: `r`번째 행의 최대/최소 점수를 계산하기 위해서는 **오직 `r-1`번째 행의 최대/최소 점수만** 알면 됩니다. 즉, $0$부터 $N-2$행까지의 모든 정보를 저장할 필요가 없습니다.
* **구현**:
    1.  크기가 3인 1차원 배열 두 개(또는 $2 \times 3$ 배열)만 선언합니다. (예: `prev_max`, `curr_max`, `prev_min`, `curr_min`)
    2.  `prev_...` 배열을 `grid[0]`(첫 번째 행)의 값으로 초기화합니다.
    3.  `r = 1`부터 `N-1`까지 반복문을 실행합니다.
    4.  `r`행의 각 열(`c=0, 1, 2`)에 대해, `prev_...` 배열을 참조하여 `curr_...` 배열의 값을 계산합니다. (예: `curr_max[1] = grid[r][1] + max(prev_max[0], prev_max[1], prev_max[2])`)
    5.  `r`행의 계산이 끝나면, `prev_...` 배열을 `curr_...` 배열의 값으로 덮어씁니다.
    6.  반복이 끝나면 `prev_...` 배열에 저장된 값이 마지막 행의 결과가 됩니다.
* 이 방식은 `N`의 크기와 관계없이 항상 고정된 크기(예: $2 \times 3 \times 2$)의 메모리만 사용하므로 **$O(1)$ 공간 복잡도**로 4MB 메모리 제한을 통과할 수 있습니다.

## 💻 코드
* [2096.py](2096.py)

---

## 💡 접근 방식 2 (PASS)

### 1. 사용 알고리즘
* **동적 계획법 (Dynamic Programming, DP)**
* **슬라이딩 윈도우 (Sliding Window) / 메모리 최적화**

### 2. 문제 풀이 과정
1.  **문제 모델링**: `r`번째 행의 `c`번째 위치에서 얻을 수 있는 최대/최소 점수는 `r-1`번째 행의 `c-1`, `c`, `c+1` 위치의 점수들에만 의존하는 **동적 계획법(DP)** 문제입니다.
2.  **핵심 과제 (메모리 제한)**: 이 문제의 핵심은 **4MB**라는 극도로 엄격한 메모리 제한입니다. `N`이 100,000일 때, `N x 3` 크기의 전체 `grid` 배열이나 `N x 3` 크기의 `dp` 배열을 저장하는 것만으로도 메모리 제한을 초과합니다.
3.  **슬라이딩 윈도우 DP 적용**:
    * 이 문제를 해결하기 위해, `r`번째 행의 값을 계산하는 데 **오직 `r-1`번째 행의 DP 값만 필요**하다는 점을 이용합니다.
    * 전체 `dp` 배열을 저장하는 대신, `max_dp`와 `min_dp`라는 크기 3의 1차원 리스트 두 개만 유지합니다. 이 리스트들은 **직전 행(previous row)**의 최대/최소 점수만을 저장합니다.
4.  **공간 최적화 구현**:
    * `grid` 배열 전체를 저장하지 않고, `input()`을 통해 **한 줄씩** 읽어옵니다.
    * `max_dp`와 `min_dp` (직전 행의 DP 값)를 참조하여, 현재 읽어온 `next_row`의 최대/최소 점수를 계산하고 이를 임시 리스트(`max_temp`, `min_temp`)에 저장합니다.
    * `r`행의 계산이 모두 끝나면, `max_dp = max_temp`, `min_dp = min_temp`와 같이 직전 행의 DP 값을 현재 행의 DP 값으로 덮어씌웁니다.
5.  **결과 도출**: 이 과정을 `N-1`번 반복하면, `max_dp`와 `min_dp`에는 최종적으로 마지막 행에 도달했을 때의 최대/최소 점수들이 저장됩니다. 이 리스트들에서 `max()`와 `min()`을 찾아 출력합니다. 이 방식은 `N`의 크기와 관계없이 항상 고정된 $O(1)$ 공간 복잡도로 문제를 해결합니다.

## 💻 코드
* [2096v2.py](2096v2.py)