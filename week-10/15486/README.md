# 15486. 퇴사 2 | 골드5

## 문제 출처
[BOJ](https://www.acmicpc.net/problem/15486)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **다이나믹 프로그래밍 (Dynamic Programming, DP)** (시도되었으나 비효율적)

### 2. 문제 풀이 과정
1.  **`daily_profit`** 리스트를 생성하여 `daily_profit[i]`가 **i일**에 얻을 수 있는 **최대 수익**을 저장하도록 모델링했습니다. (크기는 `N+1`)
2.  `0`일부터 `N-1`일까지 상담 일정을 순회하며 현재 상담 **(`term`, `profit`)**을 고려합니다.
3.  상담이 끝나는 날인 **`end_date` (`day + term`)**를 계산합니다.
4.  만약 `end_date`가 퇴사일 다음 날인 `N`일을 초과하면 해당 상담은 불가능하므로 **무시**합니다.
5.  상담이 가능한 경우, **현재 시점(`day`)까지의 최대 수익(`daily_profit[day]`)**에 **현재 상담의 수익(`profit`)**을 더한 값이 `end_date`에 기록된 기존 최대 수익보다 큰지 확인합니다.
6.  만약 새로운 수익이 더 크다면, `daily_profit[end_date]`를 **새로운 최대 수익**으로 갱신합니다.
7.  **핵심 비효율 로직:** **`end_date` 이후 모든 날(`d`부터 `N`까지)**의 최대 수익을 갱신된 `daily_profit[end_date]` 값으로 **선형 탐색(반복문)**하며 덮어씁니다. (`for d in range(end_date, N + 1)`)
8.  모든 일정을 순회한 후, `daily_profit[-1]` (즉, `N`일의 최대 수익)을 출력합니다.

***

## 💡 오류 분석 및 해결

### 1. 문제 원인
* **시간 복잡도 초과 ($\text{O}(N^2)$)**: 현재 코드는 기본적인 **다이나믹 프로그래밍** 접근을 시도했지만, 수익 갱신 과정에서 **비효율적인 반복문**을 사용했습니다.
    * 외부 `for` 문은 `N`번(`day`를 순회) 반복합니다.
    * 내부 `for` 문(`for d in range(end_date, N + 1)`)은 최악의 경우 $\text{O}(N)$번 반복합니다. (특히 `term`이 작을 때)
    * 따라서 전체 시간 복잡도는 $\text{O}(N^2)$이 됩니다. `N`의 최대 크기가 **1,500,000**이므로, $\text{O}(N^2)$는 **시간 제한(2초)**을 **훨씬 초과**하는 명백한 **시간 초과**의 원인이 됩니다.

### 2. 해결 방법
* **선형 시간 복잡도 ($\text{O}(N)$) DP로 전환:** 불필요한 내부 반복문을 제거하고, **현재 날짜(`day`)의 최대 수익**을 다음 날짜로 **이월(전파)**하는 방식으로 DP 로직을 수정해야 합니다.
    * **`dp[i]`**를 **`i`일 시점에 얻을 수 있는 최대 수익**으로 정의합니다.
    * 순회 시, 다음 두 가지를 처리합니다.
        1.  **현재 날짜의 최대 수익을 다음 날로 전파:** `dp[day + 1] = max(dp[day + 1], dp[day])`
        2.  **상담 종료일의 수익 갱신:** `end_date`가 `N` 이하라면, `dp[end_date] = max(dp[end_date], dp[day] + profit)`으로 갱신합니다.
    * 이 방식은 각 일정을 $\text{O}(1)$에 처리하여 **$\text{O}(N)$**의 시간 복잡도로 문제를 해결합니다.

## 💻 코드
* [15486.py](15486.py)

---

## 💡 접근 방식 2

### 1. 사용 알고리즘
* **다이나믹 프로그래밍 (Dynamic Programming, DP)**
* **선형 시간 복잡도 탐색 ($\text{O}(N)$)**

### 2. 문제 풀이 과정
1.  **DP 테이블 정의**: **`daily_profit`** 리스트를 **DP 테이블**로 사용합니다. `daily_profit[i]`는 **`i`일이 되었을 때** 얻을 수 있는 **최대 누적 수익**을 저장합니다. (인덱스 0부터 `N`까지 사용)
2.  **순회 및 입력**: `0`일부터 `N-1`일까지 상담 정보를 순차적으로 입력받고 처리합니다. (문제에서 입력은 `1`일부터 주어지지만, 코드에서는 0-인덱싱으로 처리)
3.  **최대 수익 전파 (Skip/Wait)**: **`day`일의 상담 여부와 관계없이**, `day`까지의 최대 수익(`daily_profit[day]`)을 다음 날인 **`day + 1`**로 전달합니다. 이는 `day`일에 상담을 하지 않고 건너뛰는 경우의 최대 수익을 다음 날에 반영하는 것입니다.
    * `daily_profit[day + 1] = max(daily_profit[day + 1], daily_profit[day])`
4.  **상담 종료일 계산 및 확인**: 현재 상담을 시작했을 때 종료되는 날인 **`end_date`** (`day + term`)를 계산합니다. **`day`일**은 **`day`일차 상담 시작** 시점을 의미하므로 `day + term`이 정확한 종료 날짜 인덱스가 됩니다. `end_date`가 퇴사일 `N`을 초과하면 해당 상담은 불가능하므로 무시합니다.
5.  **수익 갱신 (Take)**: 상담이 가능한 경우, `end_date`에 도달했을 때의 **최대 누적 수익**을 갱신합니다.
    * **`daily_profit[day]`**는 **`day`일에 상담을 시작할 수 있는 최대 수익**을 의미합니다. 여기에 현재 상담의 **`profit`**을 더한 값과, `daily_profit[end_date]`에 이미 기록된 값을 비교하여 **더 큰 값**을 저장합니다.
    * `daily_profit[end_date] = max(daily_profit[end_date], daily_profit[day] + profit)`
6.  **최종 결과**: 모든 일정을 순회한 후, `daily_profit` 리스트 전체에서 **최대값**을 찾아 출력합니다. 이 값은 `N`일차 퇴사 시점까지 얻을 수 있는 가장 큰 수익입니다.

***

## 💡 오류 분석 및 해결

### 1. 문제 원인
* **PyPy3 오답 (이전 시도)**: 이전 시도에서 PyPy3 오답이 발생했으나, 제공된 **현재 코드는 $\text{O}(N)$ DP의 정석적인 형태**를 따르고 있으며, 이는 **시간 복잡도와 로직 측면에서 가장 효율적인 해법**입니다.
* **성공적인 시간 초과 해결**: `daily_profit` 배열을 이용해 **선형 시간 복잡도 $\text{O}(N)$**로 문제를 해결함으로써, 초기 시도의 $\text{O}(N^2)$ **시간 초과** 문제를 근본적으로 해결했습니다. (각 날짜별로 두 가지 작업(전파, 갱신)을 $\text{O}(1)$에 처리)

### 2. 해결 방법
* **성공**: 현재 제공된 코드는 **$\text{O}(N)$ DP**로 효율적인 해법을 구현하였으며, 이는 PyPy3 환경에서 **724ms**라는 빠른 속도로 문제를 해결했음이 주석을 통해 확인됩니다.
* **최종 출력**: `print(max(daily_profit))`은 `N`일차 이후까지의 최대 수익을 포함하여 전체 최대값을 출력하는 것으로, `daily_profit[N]`를 출력하는 것과 사실상 동일합니다. (왜냐하면 `N`일 이후의 인덱스는 접근하지 않으므로 `daily_profit[N]`이 최종 최대값이 될 것이기 때문입니다.) 이 코드는 **효율성**과 **정확성**을 모두 확보했습니다.

## 💻 코드
* [15486v2.py](15486v2.py)
