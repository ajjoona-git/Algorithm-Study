# 2580. 스도쿠 | 골드4

## 문제 출처
[BOJ](https://www.acmicpc.net/problem/2580)

## 💡 접근 방식 (PASS)

### 1. 사용 알고리즘
* **백트래킹 (Backtracking)**
* **깊이 우선 탐색 (DFS)**

### 2. 문제 풀이 과정
1.  문제를 9x9 스도쿠 보드를 채우는 **백트래킹** 문제로 모델링합니다.
2.  먼저 9x9 보드 입력을 받아, 값이 0인 (비어있는) 모든 칸의 좌표를 `blanks` 리스트에 저장합니다.
3.  `is_possible(r, c, num)` 함수를 정의하여, 특정 좌표 `(r, c)`에 숫자 `num`을 놓는 것이 스도쿠 규칙(행, 열, 3x3 박스)에 유효한지 검사합니다.
4.  `dfs(i)` 함수를 정의하여 `blanks` 리스트의 `i`번째 빈칸을 채우는 재귀 로직을 구현합니다.
5.  `dfs(i)` 함수 내에서 1부터 9까지의 숫자를 순회하며, `is_possible` 검사를 통과하는 숫자를 현재 `i`번째 빈칸 `(r, c)`에 배치합니다.
6.  숫자를 배치한 후, 다음 빈칸을 채우기 위해 `dfs(i + 1)`을 재귀 호출합니다.
7.  만약 재귀 호출이 반환되면 (유효한 숫자를 찾지 못해 되돌아온 경우), 현재 칸의 숫자를 다시 0으로 초기화하여 **(백트래킹)** 다음 숫자 후보를 탐색합니다.
8.  모든 빈칸(`i == len(blanks)`)을 성공적으로 채우면, 완성된 스도쿠 보드를 출력하고 `exit(0)`로 프로그램을 즉시 종료하여 첫 번째 유효한 답만 출력하도록 합니다.

## 💡 오류 분석 및 해결

### 1. 문제 원인
* 코드 주석에 **"python3 시간 초과"**가 명시되어 있습니다.
* 이 풀이는 전형적인 **백트래킹** 방식으로, 빈칸의 개수(k)가 많을 경우 탐색해야 할 경우의 수가 최악의 경우 $9^k$에 근접할 수 있습니다.
* 또한, `is_possible` 함수는 숫자를 하나 놓을 때마다 행, 열, 3x3 박스를 매번 순회($O(9+9+9) \approx O(27)$)하여 유효성을 검사합니다.
* 이러한 탐색 깊이와 각 단계의 검사 비용으로 인해, 순수 Python3 인터프리터로는 1초의 시간 제한을 초과하게 됩니다.

### 2. 해결 방법
* 주석에 언급된 대로, JIT 컴파일을 지원하여 실행 속도가 매우 빠른 **Pypy3**로 제출하는 것이 가장 간단한 해결 방법입니다. (실제로 Pypy3로 통과함)
* Python3 내에서 성능을 최적화하려면, `is_possible` 함수의 시간 복잡도를 $O(1)$로 줄일 수 있습니다.
* **룩업 테이블(Lookup Table) 사용**: 3종류의 2차원 boolean 배열(또는 정수 배열)을 미리 선언합니다.
    * `row_check[r][num]`: `r`행에 숫자 `num`이 사용되었는지 여부
    * `col_check[c][num]`: `c`열에 숫자 `num`이 사용되었는지 여부
    * `box_check[box_index][num]`: `box_index`번 3x3 박스에 숫자 `num`이 사용되었는지 여부
* 이 룩업 테이블들을 사용하면 `is_possible` 검사를 $O(1)$에 수행할 수 있어 전체적인 시간 복잡도를 크게 개선할 수 있습니다.

## 💻 코드
* [2580v2.py](2580v2.py)

---

## 💡 접근 방식 (FAIL)

### 1. 사용 알고리즘
* **휴리스틱 (Heuristic)**
* **자료구조 Set (집합)**
* **제약 전파 (Constraint Propagation)** (시도)

### 2. 문제 풀이 과정
1.  스도쿠 문제를 '인간이 푸는 방식'과 유사한 **휴리스틱** 기반으로 접근합니다.
2.  `check_row`, `check_col`, `check_box` 함수를 각각 정의하여, 특정 행, 열, 3x3 박스에서 1~9의 숫자 중 아직 사용되지 않은 숫자들의 **`set` (집합)**을 반환합니다.
3.  `decide_number(r, c)` 함수는 빈칸 `(r, c)`에 대해, 위 3개 함수가 반환한 `set`들의 **교집합(`&`)**을 계산하여 유일한 후보 숫자 `candidates`를 찾습니다.
4.  만약 `candidates` 집합의 크기가 1이라면, 해당 숫자는 유일한 후보이므로 `board[r][c]`에 즉시 배치합니다.
5.  만약 `candidates` 집합의 크기가 1보다 크다면, `memo` 딕셔너리에 `{(r, c): candidates}` 형태로 가능한 후보들을 저장합니다.
6.  **"1회차 순회"**로 9x9 보드 전체를 탐색하며, `decide_number`를 호출하여 후보가 1개로 명확한 칸들을 우선적으로 채웁니다.
7.  1회차 순회 후 `memo` 딕셔너리에 남아있는 칸들(후보가 여러 개인 칸)을 후보 개수 기준으로 정렬하려 시도합니다.
8.  이후 `while memo:` 루프를 통해, 1회차에서 숫자가 채워짐으로 인해 후보가 1개로 줄어들었을 가능성이 있는 칸들을 다시 검사(`decide_number`)하며 보드 채우기를 시도합니다.

## 💡 오류 분석 및 해결

### 1. 문제 원인
* 주석에 **"런타임에러: AttributeError"**가 명시되어 있습니다.
* 오류는 `memo = sorted(memo, key=lambda x: len(x.value()))` 라인에서 발생합니다.
* `memo`는 `{(r, c): candidates_set}` 형태의 **딕셔너리**입니다. 파이썬에서 `sorted(dict)`는 딕셔너리의 **키(key) 목록**을 정렬 대상으로 사용합니다.
* 따라서 `lambda` 함수의 `x`에는 `memo`의 키인 `(r, c)` **튜플**이 전달됩니다.
* 튜플 객체는 `.value()`라는 속성(attribute)이나 메서드를 가지고 있지 않으므로, `x.value()`를 호출하는 순간 **`AttributeError: 'tuple' object has no attribute 'value'`** 예외가 발생합니다.

### 2. 해결 방법
* **문법적 해결 (AttributeError):** 딕셔너리의 '값(value)', 즉 후보 `set`의 길이를 기준으로 정렬하는 것이 의도였다면, `memo.items()`를 사용해야 합니다.
    * `memo_list = sorted(memo.items(), key=lambda item: len(item[1]))`
    * 위와 같이 수정하면 `memo_list`는 `[((r, c), {candidates...}), ...]` 형태의 **리스트**가 됩니다. (이후 `while` 루프도 이에 맞게 수정 필요)

* **논리적 해결 (근본 문제):** 이 휴리스틱 접근 방식은 후보가 1개인 칸들만 채울 수 있습니다. 만약 모든 빈칸의 후보가 2개 이상인 상태에 도달하면, 이 코드는 더 이상 진행하지 못하고 빈칸이 남은 채 종료됩니다. (이는 '오답'의 원인이 됩니다.)
* **근본적인 해결책:** 스도쿠는 하나의 빈칸에 여러 후보가 있을 때, 그중 하나를 "가정"하고 진행(탐색)하다가 막히면 다시 되돌아와야 하는 **백트래킹(Backtracking)**이 필수적입니다.
* 따라서 `memo`와 `while` 루프를 사용하는 대신, 빈칸의 목록(`blanks`)을 만들고 **DFS(깊이 우선 탐색)** 재귀 함수를 사용하여 빈칸을 하나씩 채워나가는 **완전 탐색** 방식으로 전환해야 합니다.

## 💻 코드
* [2580.py](2580.py)