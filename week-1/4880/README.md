# 4880: 토너먼트 카드게임 | D2

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AWTQgnH6Qq4DFAVT&probBoxId=AZgvQCv6GNbHBIT9&type=PROBLEM&problemBoxTitle=7%EC%9B%94&problemBoxCnt=19)

## 💡 접근 방식

### 1. 사용 알고리즘
* **분할 정복(Divide and Conquer)**
* **재귀(Recursion)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받습니다.
2.  이 문제는 토너먼트 방식으로 승자를 가리므로, 전체 참가자 그룹을 절반씩 나누어 최종 한 명이 남을 때까지 반복하는 **분할 정복** 알고리즘을 사용합니다. 이 과정은 **재귀 함수**를 통해 효과적으로 구현할 수 있습니다.
3.  `cut_in_half(i, j)` 재귀 함수를 정의합니다. 이 함수는 `i`부터 `j`까지의 인덱스 범위를 받아 그룹을 절반으로 나눕니다.
    * 그룹의 크기가 2명 이하(`j - i <= 1`)일 경우, 두 사람의 카드를 비교하여 승자를 결정합니다.
    * 그룹이 더 크다면, `cut_in_half(i, (i+j)//2)`와 `cut_in_half((i+j)//2+1, j)`를 재귀적으로 호출하여 그룹을 반으로 나눕니다.
4.  두 사람의 카드를 비교하여 승자를 판별하는 `who_is_winner(a, b)` 함수를 정의합니다.
    * 카드의 숫자(1:가위, 2:바위, 3:보)를 비교하여 승자를 결정합니다. `cards[a] - cards[b]`의 결과로 승패를 간단하게 판별할 수 있습니다.
    * **`a-b`의 결과가 `1` 또는 `-2`이면 `a` 승리**, **`a-b`의 결과가 `-1` 또는 `2`이면 `b` 승리**가 됩니다.
    * 비긴 경우, 문제 조건에 따라 인덱스가 작은 쪽(`a`)이 승자가 되므로, 이 경우도 고려하여 반환합니다.
5.  각 테스트 케이스마다 참가자 수 `N`과 카드 정보를 입력받습니다.
6.  `cut_in_half(0, N-1)` 함수를 호출하여 최종 승자의 인덱스를 찾습니다.
7.  학생 번호는 1번부터 시작하므로, 최종 승자 인덱스에 `1`을 더하여 출력합니다.

---

## 💻 코드
* [4880.py](4880.py)