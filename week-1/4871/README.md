# 4871: 그래프 경로 | D2

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AWTQaUvqQdUDFAVT&probBoxId=AZgvQCv6GNbHBIT9&type=PROBLEM&problemBoxTitle=7%EC%9B%94&problemBoxCnt=19)

## 💡 접근 방식

### 1. 사용 알고리즘
* **깊이 우선 탐색(DFS, Depth-First Search)**
* **스택(Stack)** 또는 **재귀 호출**을 활용한 탐색

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받습니다.
2.  각 테스트 케이스마다 노드와 간선 정보를 바탕으로 그래프를 만듭니다. 노드 번호가 1번부터 시작하므로, `(V+1) x (V+1)` 크기의 2차원 리스트 `graph`를 만들어 인접 행렬 방식으로 그래프를 표현합니다.
3.  주어진 `E`개의 간선 정보를 `graph`에 표시합니다. 출발 노드 `i`, 도착 노드 `j`에 대해 `graph[i][j]` 값을 `1`로 설정하여 방향성 그래프를 나타냅니다.
4.  경로의 존재 여부를 탐색하기 위해 **깊이 우선 탐색(DFS)**을 사용합니다. 이를 위해 현재 노드를 저장할 변수 `i`와 방문했던 노드를 저장할 스택 `visited`를 준비합니다.
5.  `S`(출발 노드)에서 탐색을 시작합니다. `while` 반복문을 통해 스택 `visited`가 비어있지 않는 한 탐색을 계속합니다.
6.  현재 노드 `i`에서 연결된 다음 노드 `j`를 찾습니다. `graph[i].index(1)`를 사용해 `1`이 있는 인덱스를 찾습니다.
7.  다음 노드 `j`가 `G`(도착 노드)와 같다면, 경로가 존재하므로 결과를 `1`로 설정하고 탐색을 종료합니다.
8.  `G`가 아니라면, 현재 노드 `i`를 `visited` 스택에 추가하고 다음 노드 `j`로 이동하여 탐색을 이어갑니다. `graph[i][j]`를 `0`으로 변경하여 이미 방문한 간선임을 표시합니다.
9.  만약 현재 노드 `i`에서 더 이상 갈 수 있는 경로가 없다면(즉, `graph[i].index(1)`에서 `ValueError` 발생), `visited` 스택에서 이전 노드를 `pop`하여 돌아갑니다(백트래킹).
10. 스택 `visited`가 모두 비워질 때까지 `G`를 찾지 못했다면 경로가 존재하지 않는 것으로 판단하여 결과는 `0`이 됩니다.
11. 최종 결과를 테스트 케이스 번호와 함께 출력합니다.



---

## 💻 코드
* [4871.py](4871.py)