# 4881: 배열 최소 합 | D2

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AWTQh00qQs0DFAVT&probBoxId=AZgvQCv6GNbHBIT9&type=PROBLEM&problemBoxTitle=7%EC%9B%94&problemBoxCnt=19)

## 💡 접근 방식

### 1. 사용 알고리즘
* **백트래킹(Backtracking)**
* **재귀(Recursion)**와 **가지치기(Pruning)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 `N x N` 크기의 배열 `numbers`를 2차원 리스트로 저장합니다.
2.  이 문제는 모든 행과 열에서 하나씩 숫자를 선택하는 모든 경우의 수를 탐색하여 합이 최소가 되는 경우를 찾아야 하므로 **백트래킹** 알고리즘을 사용합니다.
3.  탐색을 위해 재귀 함수 `sumation(x, subtotal)`을 정의합니다. `x`는 현재 탐색 중인 행의 번호이며, `subtotal`은 현재까지 선택한 숫자들의 합을 의미합니다.
4.  `visited` 배열을 사용하여 이미 선택된 열의 인덱스를 기록함으로써 각 열에서 한 번만 숫자를 선택하도록 합니다.
5.  **가지치기(Pruning)**를 통해 불필요한 탐색을 줄입니다. 현재까지의 합(`subtotal`)이 이미 최소 합(`min_sum`)보다 크거나 같아지면, 더 이상 탐색을 진행해도 최솟값을 찾을 수 없으므로 해당 경로의 탐색을 중단하고 돌아갑니다.
6.  `x == N`이 되면 모든 행의 숫자를 하나씩 선택한 것이므로, 현재의 `subtotal`과 기존의 `min_sum`을 비교하여 `min_sum`을 갱신합니다.
7.  각 행 `x`에 대해 모든 열 `y`를 순회하며 `visited[y]`가 `False`인 경우(즉, 아직 선택하지 않은 열)에만 재귀 호출을 진행합니다.
8.  재귀 호출이 끝나고 돌아올 때, `visited[y] = False`로 되돌려(백트래킹) 다음 경우의 수를 탐색할 수 있도록 합니다.
9.  초기 호출은 `sumation(0, 0)`으로 시작하고, 모든 탐색이 끝나면 `min_sum`에 저장된 최종 결과를 출력합니다.


### 3. 최소값을 찾아 더하는 방식이 안되는 이유
이 문제는 **모든 행과 열에서 각각 하나의 숫자를 선택**하는 모든 조합을 고려해야 합니다. 단순히 매 행에서 최소값을 찾아 더하는 **그리디(Greedy)** 방식으로는 올바른 답을 찾을 수 없습니다.

예를 들어, 다음과 같은 배열이 있다고 가정해 봅시다.

[ [1, 5, 2],
  [4, 1, 3],
  [2, 3, 1] ]

* **그리디 방식 (매 행에서 최소값 선택)**
    * 1행에서 최소값: `1` (1행, 0열)
    * 2행에서 최소값: `1` (2행, 1열)
    * 3행에서 최소값: `1` (3행, 2열)
    * 합: `1 + 1 + 1 = 3`
    * 이 경우 각 행과 열에서 하나씩만 선택하는 조건이 만족됩니다.

* **백트래킹 방식 (올바른 해)**
    * 만약 1행에서 `2`를 선택하고, 2행에서 `1`을 선택하고, 3행에서 `1`을 선택한다면 합은 `2 + 1 + 1 = 4`가 됩니다.
    * 하지만 1행에서 `1`, 2행에서 `3`, 3행에서 `1`을 선택하면 합은 `1 + 3 + 1 = 5`가 됩니다.
    * 이처럼 최적의 해는 단순히 각 행의 최소값을 더하는 것으로는 찾을 수 없습니다.

그리디 방식은 현재의 선택이 미래의 최적의 선택으로 이어질 것이라는 가정을 하지만, 이 문제에서는 특정 열을 선택하면 해당 열의 다른 행은 선택할 수 없기 때문에 이러한 가정이 성립하지 않습니다. 따라서 모든 가능한 경우의 수를 탐색하는 **백트래킹**을 사용해야만 정답을 찾을 수 있습니다.


---

## 💻 코드
* [4881.py](4881.py)