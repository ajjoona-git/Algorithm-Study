# 1799. 비숍 | 플래티넘 V

## 문제 출처
[BOJ](https://www.acmicpc.net/problem/1799)

## 💡 접근 방식

### 1. 사용 알고리즘
* **백트래킹 (Backtracking)**
* **깊이 우선 탐색 (DFS, Depth-First Search)**
* **분할 정복 (Divide and Conquer)**

### 2. 문제 풀이 과정
1.  **핵심 아이디어 (분할 정복)**: 체스판에서 비숍은 자신이 있는 칸과 같은 색의 칸으로만 이동하고 공격할 수 있습니다. 즉, **흰색 칸에 있는 비숍은 검은색 칸의 비숍을 절대 공격할 수 없으며, 그 반대도 마찬가지**입니다. 이 특징을 이용해, 전체 문제를 두 개의 독립적인 하위 문제로 나눌 수 있습니다.
    1.  흰색 칸에만 비숍을 놓아 최대 개수를 구하는 문제
    2.  검은색 칸에만 비숍을 놓아 최대 개수를 구하는 문제
    * 최종 결과는 두 문제에서 구한 최대 개수의 합이 됩니다.

2.  **하위 문제 해결 (백트래킹)**:
    * 각각의 색깔 칸에 대해 비숍을 놓는 문제는 **백트래킹**을 사용하여 해결합니다.
    * `dfs_even` (흰색 칸 탐색), `dfs_odd` (검은색 칸 탐색)와 같이 각 색깔의 칸만 순회하는 별도의 재귀 함수를 설계합니다.
    * 각 칸에 대해 **'비숍을 놓는 경우'**와 **'놓지 않는 경우'** 두 가지 선택지를 모두 탐색합니다.
    * **'비숍을 놓는 경우'**: 현재 칸에 비숍을 놓을 수 있다면(다른 비숍의 공격 경로에 있지 않다면), 비숍을 놓고 `count`를 1 증가시킨 후 다음 칸으로 재귀 호출합니다.
    * **'비숍을 놓지 않는 경우'**: 현재 칸에 비숍을 놓지 않고 `count` 변경 없이 다음 칸으로 재귀 호출합니다.
3.  **구현 상세**:
    * 코드는 `dfs_odd`와 `dfs_even` 함수를 통해 각각의 색깔 판을 탐색합니다. 다음 탐색 위치로 이동할 때 2칸씩 건너뛰거나(`c + 2`), 다음 줄로 넘어갈 때 시작 열을 조정하여 같은 색의 칸만 방문하도록 구현합니다.
    * 비숍을 놓을 때마다 해당 비숍이 공격하는 대각선 경로를 `visited` 배열에 표시하고, 이를 다음 재귀 호출에 넘겨주어 다음 비숍이 놓일 수 있는 위치를 제한합니다.

4.  **결과 도출**: `dfs_odd`와 `dfs_even`을 각각 실행하여 얻은 최대 비숍의 개수(`max_count_odd`, `max_count_even`)를 합산하여 최종 결과를 출력합니다.

## 💡 오류 분석 및 해결

### 1. 문제 원인
* **초기 접근 1 (Greedy)**: 주석의 첫 번째 시도처럼, 단순히 순서대로 놓을 수 있는 곳에 비숍을 놓고 대각선을 지워나가는 그리디 방식은 최적해를 보장하지 않습니다. 먼저 놓은 비숍 때문에 놓을 수 없게 된 여러 칸 중에 최적의 해답이 포함되어 있을 수 있습니다.
* **초기 접근 2 (단순 백트래킹 - 시간 초과)**: 주석의 여러 `dfs` 시도처럼, 전체 N x N 보드를 하나의 문제로 보고 백트래킹을 적용하면 탐색해야 할 상태 공간이 너무 커져($2^{N^2}$) 시간 초과가 발생합니다. 각 재귀 호출마다 보드 전체를 복사하거나 `set`을 병합하는 방식 또한 매우 비효율적입니다.

### 2. 해결 방법
* **문제 분할**: 위에서 설명한 것처럼, 체스판을 **색깔에 따라 두 개의 독립적인 문제로 분할**하는 것이 이 문제의 핵심입니다.
* 이 **분할 정복** 전략을 통해 탐색 공간의 크기를 $2^{N^2}$에서 약 $2 \times 2^{(N^2/2)}$ 수준으로 대폭 줄일 수 있습니다.
* 이렇게 크기가 줄어든 각 하위 문제에 대해 **백트래킹**을 적용하면, 제한 시간 내에 최대 비숍의 개수를 찾는 것이 가능해집니다.

---

## 💻 코드
* [1799.py](1799.py)