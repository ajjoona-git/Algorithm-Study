# 2018 KAKAO BLIND RECRUITMENT: [3차]방금그곡 | Lv.2

## 문제 출처
[Programmers](https://school.programmers.co.kr/learn/courses/30/lessons/17683)

## 💡 접근 방식

### 1. 사용 알고리즘
* **구현 (Implementation)**
* **시뮬레이션 (Simulation)**
* **문자열 처리 (String Manipulation)**

### 2. 문제 풀이 과정
1.  [문제에 대한 간략한 모델링 또는 핵심 아이디어를 설명합니다.]
    * 각 음악 정보에 대해, 실제 재생 시간만큼의 전체 멜로디를 생성(시뮬레이션)한 후, 기억하는 멜로디(`m`)가 그 안에 포함되어 있는지 확인하는 문제입니다.
    * 여러 곡이 일치할 경우, 재생 시간이 가장 길고, 재생 시간도 같다면 먼저 입력된 곡을 선택해야 하는 우선순위 조건이 있습니다.

2.  [코드의 첫 번째 주요 단계에 대한 설명을 작성합니다.]
    * **'#'(샵) 음 처리**: 'C#'과 'C'는 다른 음이지만, 문자열 검색 시 'C'가 'C#'에 포함되는 것으로 인식될 수 있습니다. 이러한 모호성을 없애기 위해, 'C#', 'D#' 같은 샵이 붙은 음들을 'c', 'd' 등과 같은 하나의 소문자로 치환하는 전처리 과정을 거칩니다. 이 과정은 기억하는 멜로디 `m`과 모든 음악 정보의 멜로디에 동일하게 적용됩니다.

3.  [코드의 두 번째 주요 단계에 대한 설명을 작성합니다.]
    * **재생 멜로디 시뮬레이션**: 각 음악 정보에 대해 시작 시간과 종료 시간의 차이를 분 단위로 계산하여 총 재생 시간을 구합니다.
    * `for`문과 모듈러 연산(`%`)을 사용하여, 원본 멜로디가 총 재생 시간만큼 반복되거나 잘려서 실제로 재생된 전체 멜로디 문자열을 생성합니다.

4.  [코드의 논리적 흐름에 따라 필요한 만큼 단계를 추가합니다.]
    * **후보곡 정렬**: 모든 음악 정보에 대한 시뮬레이션이 끝나면, 문제의 우선순위 조건에 따라 후보곡들을 정렬합니다.
    * 정렬 기준은 **첫째, 재생 시간이 긴 순서(내림차순)**, **둘째, 먼저 입력된 순서(오름차순)**입니다.

5.  [최종 결과를 도출하는 과정을 설명하며 마무리합니다.]
    * **정답 찾기**: 정렬된 후보곡 리스트를 순회하면서, 전처리된 기억하는 멜로디(`m`)가 현재 곡의 전체 재생 멜로디에 포함(`in`)되는지 확인합니다.
    * 후보곡 리스트는 이미 우선순위에 따라 정렬되어 있으므로, **가장 먼저 발견되는 일치하는 곡**이 바로 정답이 됩니다. 해당 곡의 제목을 즉시 반환합니다.
    * 만약 모든 후보곡을 확인했는데도 일치하는 곡이 없다면, `(None)`을 반환합니다.


---

## 💻 코드
* [17683.py](17683.py)