# 2024 KAKAO WINTER INTERNSHIP: 도넛과 막대 그래프 | Lv.2

## 문제 출처
[Programmers](https://school.programmers.co.kr/learn/courses/30/lessons/258711)

## 💡 접근 방식 1 (FAIL)

### 1. 사용 알고리즘
* **그래프 탐색 (DFS)**
* **인접 리스트(Adjacency List)**

### 2. 문제 풀이 과정
1.  입력받은 `edges`를 이용해 그래프를 **인접 리스트** 형태로 만듭니다.
2.  모든 노드를 진출 차수가 높은 순서대로 정렬하여 순회합니다. 이는 생성 정점을 먼저 찾으려는 시도로 보입니다.
3.  아직 방문하지 않은 노드를 시작점으로 `define_type` 함수를 호출하여 그래프의 형태를 판별합니다.
4.  `define_type` 함수는 **DFS**와 유사한 방식으로 그래프를 탐색하며, 사이클의 존재 여부와 형태를 통해 도넛, 막대, 8자 모양을 구분하려고 시도합니다.
5.  판별된 그래프 종류에 따라 카운트를 증가시키고, 해당 그래프에 속한 모든 노드를 다음 탐색에서 제외합니다.

## 💡 오류 분석 및 해결

### 1. 문제 원인
* **시간 초과**: 모든 정점에 대해 그래프 전체를 탐색하는 **DFS** 방식은 비효율적입니다. 생성 정점과 연결된 각 서브그래프의 시작점을 찾아 탐색을 반복하는 과정은 정점과 간선의 수가 많아질 경우 시간 복잡도가 크게 증가하여 **시간 초과**를 유발합니다.
* **오답**: `define_type` 함수에서 사이클의 형태만으로 그래프 종류를 판별하는 로직이 문제입니다. 탐색 시작점에 따라 노드 방문 순서가 달라져 도넛 모양과 8자 모양을 구분하는 조건문(`elif next_node == node: ...`)이 특정 케이스를 처리하지 못하는 등 로직의 허점으로 인해 **오답**이 발생합니다.

### 2. 해결 방법
* 이 문제는 그래프를 직접 탐색하는 대신, 각 정점의 **진입 차수(In-degree)**와 **진출 차수(Out-degree)**를 활용하는 것이 훨씬 효율적이고 정확합니다.
* **생성 정점**(진입 0, 진출 ≥ 2), **막대 그래프의 끝점**(진출 0), **8자 그래프의 중심점**(진입 ≥ 2, 진출 2)과 같이, 각 그래프는 차수 정보로 구별되는 고유한 특징점을 가집니다. 이 특징점들의 개수를 세는 방식으로 O(N) 시간 복잡도로 문제를 해결할 수 있습니다.

## 💻 코드
* [258711.py](258711.py)

---

## 💡 접근 방식 2 (PASS)

### 1. 사용 알고리즘
* **그래프 이론(Graph Theory)**
* **해시 맵(Hash Map)**

### 2. 문제 풀이 과정
1.  주어진 간선 정보(`edges`)를 바탕으로, 각 정점의 **진입 차수(In-degree)**와 **진출 차수(Out-degree)**를 계산하여 딕셔너리(해시 맵)에 저장합니다.
2.  차수 정보가 저장된 딕셔너리를 순회하며 각 그래프의 종류를 판별하는 특징점을 찾습니다.
3.  **생성 정점**의 특징(진입 차수 0, 진출 차수 2 이상)을 이용해 생성 정점을 찾습니다. 이 정점의 진출 차수는 연결된 전체 그래프의 개수와 같습니다.
4.  **막대 그래프**는 진출 차수가 0인 끝 점을 반드시 가지므로, 이 특징을 가진 정점의 수를 셉니다.
5.  **8자 모양 그래프**는 진입 차수와 진출 차수가 모두 2인 중심점을 가지므로, 이 특징을 가진 정점의 수를 셉니다.
6.  마지막으로, **도넛 모양 그래프**의 개수는 전체 그래프 개수(생성 정점의 진출 차수)에서 막대 그래프와 8자 모양 그래프의 개수를 빼서 계산합니다.

## 💻 코드
* [258711v2.py](258711v2.py)