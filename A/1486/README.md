# 1486. 장훈이의 높은 선반 | D4

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AV2b7Yf6ABcBBASw&probBoxId=AZiiM-4KAVbHBIT9&type=PROBLEM&problemBoxTitle=A%ED%98%95_%EC%B6%94%EC%B2%9C+%ED%95%99%EC%8A%B5+%EC%9E%90%EB%A3%8C&problemBoxCnt=24)

## 💡 접근 방식

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search)**
* **부분 집합 (Powerset)**
* **비트마스킹 (Bitmasking)**

### 2. 문제 풀이 과정
1.  **문제 정의**: N명의 점원들 중 일부를 선택하여 탑을 쌓았을 때, 그 높이의 합(`S`)이 선반의 높이(`B`) 이상이 되는 경우 중 `S - B`의 값이 최소가 되는 경우를 찾는 문제입니다. 이는 점원들의 모든 조합, 즉 **모든 부분 집합**을 고려해야 하는 문제입니다.
2.  **알고리즘 선택**: 점원의 수(N)가 최대 20으로 크지 않기 때문에, 모든 경우의 수($2^N$)를 탐색하는 **완전 탐색**이 가능합니다. 모든 부분 집합을 효율적으로 생성하기 위해 **비트마스킹** 기법을 사용합니다.
3.  **비트마스킹을 이용한 부분 집합 구현**:
    * `0`부터 `2^N - 1`까지의 각 정수는 N개의 비트로 표현할 수 있으며, 이 N개의 비트를 각 점원이 탑에 포함되는지 여부(`1` 또는 `0`)에 대응시킵니다.
    * 예를 들어, `N=3`일 때 정수 `5`는 이진수로 `101`이며, 이는 0번 점원과 2번 점원은 포함하고 1번 점원은 포함하지 않는 부분 집합을 의미합니다.
    * `for i in range(2**N)` 루프를 통해 모든 부분 집합을 순회합니다.
    * `if i & (1 << j)` 연산을 사용하여, 현재 정수 `i`의 `j`번째 비트가 `1`인지 확인하고, `1`이라면 `j`번째 점원의 키를 합산합니다.
4.  **최소 차이 계산**:
    * 각 부분 집합에 대한 키의 합(`current_sum`)을 계산합니다.
    * `current_sum`이 선반의 높이 `B` 이상인 경우에만, `current_sum - B` 값을 기존의 최소 차이(`min_diff`)와 비교하여 더 작은 값으로 갱신합니다.
5.  **초기화 및 실행**:
    * `min_diff`를 충분히 큰 값으로 초기화한 후, `make_powerset()` 함수를 실행하여 모든 부분 집합을 탐색합니다.
    * 모든 탐색이 완료되면 `min_diff`에 저장된 값이 최종 결과가 됩니다.


---

## 💻 코드
* [1486.py](1486.py)