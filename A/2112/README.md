# 2112. 보호 필름

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AV5V1SYKAaUDFAWu&probBoxId=AZiiM-4KAVbHBIT9&type=PROBLEM&problemBoxTitle=A%ED%98%95_%EC%B6%94%EC%B2%9C+%ED%95%99%EC%8A%B5+%EC%9E%90%EB%A3%8C&problemBoxCnt=25)

## 💡 접근 방식

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search) / DFS**
* **재귀 (Recursion) & 백트래킹 (Backtracking)**
* **가지치기 (Pruning)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 각 행(row)에 대해 **1) 약품을 투입하지 않거나, 2) A약품을 투입하거나, 3) B약품을 투입하는** 3가지 선택지가 있습니다. 총 D개의 행이 있으므로, 모든 경우의 수는 $3^D$가 됩니다. 이 모든 경우의 수를 탐색하여 최소 약품 투입 횟수를 찾는 **완전 탐색** 문제로 접근합니다.
2.  **재귀를 이용한 DFS 설계**:
    * `select_row_status(row_idx, drug_cnt)`라는 재귀 함수를 설계하여 깊이 우선 탐색(DFS) 방식으로 모든 경우의 수를 탐색합니다.
    * `row_idx`는 현재 약품 투입 여부를 결정할 행의 번호, `drug_cnt`는 현재까지 투입한 약품의 횟수를 의미합니다.
3.  **종료 조건 및 성능 검사**:
    * **종료 조건**: `row_idx`가 D가 되면(모든 행에 대한 결정이 끝나면), 현재 상태의 필름(`section`)이 성능 검사를 통과하는지 `is_passed` 함수를 통해 확인합니다.
    * **최소값 갱신**: 만약 성능 검사를 통과했다면, 현재까지의 약품 투입 횟수 `drug_cnt`를 전역 변수 `min_drug`과 비교하여 더 작은 값으로 갱신합니다.
4.  **가지치기(Pruning)를 통한 최적화**:
    * 재귀 탐색 중에 현재 약품 투입 횟수 `drug_cnt`가 이미 이전에 찾은 최소 횟수 `min_drug`보다 크거나 같아진다면, 더 이상 탐색을 진행해도 더 좋은 결과를 얻을 수 없습니다.
    * 이 경우, 즉시 `return`하여 불필요한 탐색을 중단하고 효율성을 높입니다.
5.  **백트래킹**:
    * 현재 행 `row_idx`에 대해 3가지 선택지를 탐색합니다.
        1.  **약품 미투입**: `drug_cnt` 변경 없이 다음 행(`row_idx + 1`)으로 재귀 호출합니다.
        2.  **A약품 투입**: 현재 행의 원본 데이터를 백업한 후, 해당 행을 모두 0으로 바꿉니다. `drug_cnt + 1`과 함께 다음 행으로 재귀 호출합니다.
        3.  **B약품 투입**: 해당 행을 모두 1로 바꾼 후, `drug_cnt + 1`과 함께 다음 행으로 재귀 호출합니다.
    * A, B 약품 투입에 대한 탐색이 모두 끝난 후에는, **백업해 둔 원본 데이터로 현재 행을 복원**합니다. 이 과정을 통해 다른 탐색 경로에 영향을 주지 않도록 합니다(백트래킹).
6.  **실행**: `select_row_status(0, 0)`을 호출하여 0번 행부터 탐색을 시작하고, 최종적으로 `min_drug`에 저장된 값을 출력합니다.

---

## 💻 코드
* [2112.py](2112.py)