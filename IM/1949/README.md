# 1949. 등산로 조성

## 💡 접근 방식

### 1. 사용 알고리즘
* **깊이 우선 탐색(DFS, Depth-First Search)**
* **백트래킹(Backtracking)** 및 **가지치기(Pruning)**
* **재귀(Recursion)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 지도의 크기 `N`과 최대 공사 가능 깊이 `K`를 입력받습니다.
2.  `N x N` 크기의 지도 `grid`를 입력받아 저장하고, 방문 여부를 기록할 `visited` 2차원 배열을 `False`로 초기화합니다.
3.  지도의 모든 칸을 순회하여 가장 높은 봉우리의 높이 `max_height`를 찾습니다.
4.  가장 높은 봉우리를 출발점으로 삼아 가장 긴 등산로의 길이를 탐색합니다. `longest_len`을 `0`으로 초기화하고, `max_height`와 같은 높이를 가진 모든 봉우리에서 `explore_path` 함수를 호출합니다.
5.  `explore_path(r, c, current_len, is_cut_valid)` 재귀 함수는 현재 위치 `(r, c)`에서 시작하는 등산로를 탐색합니다.
    * `visited` 배열을 사용하여 이미 방문한 곳은 다시 방문하지 않도록 합니다.
    * 현재까지의 길이 `current_len`이 `longest_len`보다 길면 `longest_len`을 갱신합니다.
    * 현재 위치에서 상하좌우를 탐색하여 다음으로 이동할 칸 `(nr, nc)`를 찾습니다.
    * **다음 칸이 현재 칸보다 낮은 경우**: 그대로 `current_len`을 1 증가시켜 다음 칸으로 이동합니다.
    * **공사(`is_cut_valid`)가 가능한 경우**: 다음 칸이 현재 칸보다 높더라도, 공사 가능 깊이 `K`를 활용해 높이를 낮출 수 있다면 공사를 진행하고 탐색을 이어갑니다. 이때 `is_cut_valid`를 `False`로 바꿔 더 이상 공사할 수 없음을 표시합니다.
    * 재귀 호출이 끝난 후에는 `visited`와 `grid`를 원래 상태로 되돌리는 **백트래킹**을 수행하여 다른 경로를 탐색할 수 있도록 합니다.


---

## 💻 코드
* [1949.py](1949.py)
