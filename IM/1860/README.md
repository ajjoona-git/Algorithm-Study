# 1860. 진기의 최고급 붕어빵 | D3

## 💡 접근 방식

### 1. 사용 알고리즘
* **구현(Implementation)**
* **그리디(Greedy)** 알고리즘
* **배열 순회(Array Traversal)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 예약 손님 수 `N`, 붕어빵 생산 주기 `M`, 생산 개수 `K`를 입력받습니다.
2.  손님들이 오는 시간을 담은 `reserved_time` 리스트를 입력받고, **시간 순서대로 처리**하기 위해 오름차순으로 정렬합니다.
3.  판매한 붕어빵의 수량을 저장할 `sold_stock` 변수를 `0`으로 초기화하고, 가능 여부를 판별할 `state` 변수를 준비합니다.
4.  `for` 반복문을 사용하여 예약 손님의 수(`N`)만큼 순회하면서 각 손님에게 붕어빵을 제공할 수 있는지 판단합니다.
5.  각 손님의 예약 시간(`reserved_time[i]`)에 만들 수 있는 붕어빵의 총 개수는 `(reserved_time[i] // M) * K`입니다. 여기서 `sold_stock`을 뺀 값이 현재 판매 가능한 붕어빵 재고가 됩니다.
6.  현재 재고가 `0` 이하라면, 붕어빵을 제공할 수 없으므로 `state`를 `"Impossible"`로 설정하고 반복문을 `break`합니다.
7.  만약 재고가 `0`보다 크다면 붕어빵을 판매할 수 있으므로, `sold_stock`을 1 증가시킵니다.
8.  모든 손님에 대한 검사가 끝난 후, `sold_stock`이 `N`과 같다면 모든 손님에게 붕어빵을 제공한 것이므로 `state`를 `"Possible"`로 설정합니다.
9.  최종적으로 `state`에 저장된 값을 출력 형식에 맞춰 출력합니다.

---

## 💻 코드
* [1860.py](1860.py)
