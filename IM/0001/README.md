# 기출 복원. 탑 쌓기

## 💡 접근 방식 1: 

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 선택 정렬(Selection Sort)
* **그리디(Greedy)** 알고리즘

### 2. 문제 풀이 과정
1.  먼저 전체 화물의 수 `N`, 탑1과 탑2의 높이 `W1`, `W2`, 그리고 `N`개의 화물 무게가 담긴 리스트 `weights`를 입력받습니다.
2.  무거운 화물을 낮은 층에 쌓아야 비용을 최소화할 수 있으므로, **선택 정렬**을 사용하여 화물의 무게를 내림차순으로 정렬합니다.
3.  정렬된 화물 리스트를 순회하며 가장 무거운 화물부터 순차적으로 두 탑에 배정하는 **그리디** 전략을 사용합니다. 이 때 `for` 반복문을 통해 홀수/짝수 번째 화물을 번갈아 탑1과 탑2에 배정합니다.
4.  만약 현재 배정하려는 탑이 이미 최대 높이에 도달했다면, 다른 탑에 화물을 배정합니다.
5.  모든 화물 배정이 끝나면, `calculate_expense` 함수를 사용하여 각 탑의 비용을 계산합니다. 이 함수는 각 화물의 무게에 쌓인 층수(인덱스)를 곱하여 합산합니다.
6.  두 탑의 비용을 더하여 총 최저 비용을 구하고, 결과를 출력 형식에 맞춰 출력합니다.

---

## 💻 코드
* [0001.py](0001.py)

## 💡 접근 방식 2: 수학적 접근

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 선택 정렬(Selection Sort)
* **그리디(Greedy)** 알고리즘

### 2. 문제 풀이 과정
1.  먼저 화물의 무게를 내림차순으로 정렬합니다. 가장 무거운 화물부터 순서대로 낮은 층에 배치해야 전체 비용을 최소화할 수 있다는 **그리디(Greedy)** 전략을 적용하기 위함입니다.
2.  두 탑의 높이(`W1`, `W2`)에 맞춰 각 화물에 곱해질 '층수'에 해당하는 계수(coefficient) 리스트를 생성합니다. (예: `W1=2, W2=3`이면 계수는 `1, 2, 1, 2, 3`이 됩니다.)
3.  비용을 최소화하려면 무거운 화물에는 낮은 계수(낮은 층)를, 가벼운 화물에는 높은 계수(높은 층)를 곱해야 합니다. 따라서, 앞서 생성한 계수 리스트를 오름차순으로 정렬합니다.
4.  내림차순으로 정렬된 화물 무게 리스트와 오름차순으로 정렬된 계수 리스트를 순회하며, 동일한 인덱스끼리 곱하여 합산합니다. 이 합산된 값이 최소 비용이 됩니다.
5.  최종적으로 계산된 최소 비용을 출력 형식에 맞춰 출력합니다.


---

## 💻 코드
* [0001v2.py](0001v2.py)
