# 1211. Ladder2 | D4

## 💡 접근 방식

### 1. 사용 알고리즘
* **구현(Implementation)**
* **브루트포스(Brute-force)**
* **2차원 배열 순회** 및 **방향 벡터(Delta Array)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스 번호와 100x100 크기의 사다리 배열 `ladder`를 입력받습니다.
2.  이 문제는 모든 가능한 출발점(`'1'`)에서 시작하여 도착점(`바닥`)까지의 경로 길이를 모두 계산하고, 그 중 가장 짧은 경로의 출발점을 찾는 방식으로 해결합니다.
3.  `calculate_length` 함수를 정의하여, 특정 출발점(`(0, x)`)에서 시작하는 경로의 길이를 계산합니다.
4.  사다리를 탐색하는 과정은 델타 배열(`dr`, `dc`)을 사용하여 좌, 우, 아래 순서로 이동하는 방식을 따릅니다.
5.  `while` 반복문을 사용하여 사다리의 바닥에 도달할 때까지 탐색을 계속합니다.
6.  `for` 반복문을 통해 좌, 우, 아래 방향을 순서대로 확인하며 `'1'`이 있는 경로를 찾습니다. 이때, 좌우로 이동할 수 있는 경로가 있다면 우선적으로 이동하고, 더 이상 좌우로 갈 수 없으면 아래로 이동합니다.
7.  무한 루프에 빠지는 것을 방지하기 위해 `visited` 배열을 사용하여 이미 방문한 경로를 다시 방문하지 않도록 합니다.
8.  `calculate_length` 함수는 최종적으로 경로의 길이를 반환합니다.
9.  `for i in range(N)` 반복문을 사용하여 첫 번째 행의 모든 `'1'` 위치를 출발점으로 하여 `calculate_length` 함수를 호출합니다.
10. 계산된 경로의 길이가 현재까지의 최소 길이보다 짧으면, 최소 길이를 갱신하고 해당 출발점(`i`)을 저장합니다.
11. 모든 출발점에 대한 계산이 끝나면, 저장된 최단 경로의 출발점을 출력 형식에 맞춰 출력합니다.

---

## 💻 코드
* [1211.py](1211.py)
