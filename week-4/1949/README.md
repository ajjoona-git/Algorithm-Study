# 1949. 등산로 조성

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AV5PoOKKAPIDFAUq&probBoxId=AZjE2kOaAXDHBIO0&type=PROBLEM&problemBoxTitle=8%EC%9B%94+3-4%EC%A3%BC%EC%B0%A8%288%2F28%EA%B9%8C%EC%A7%80+%ED%91%B8%EC%8B%9C%EC%98%A4%29&problemBoxCnt=4)

## 💡 접근 방식

### 1. 사용 알고리즘
* **깊이 우선 탐색 (DFS, Depth-First Search)**
* **백트래킹 (Backtracking)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 등산로는 지형의 높이가 반드시 낮아지는 방향으로만 건설할 수 있으므로, 모든 가능한 경로를 탐색해야 하는 문제입니다. 이는 **깊이 우선 탐색(DFS)**을 활용하기에 적합합니다.
2.  **시작점 탐색**: 등산로는 가장 높은 봉우리에서 시작해야 합니다. `find_highest` 함수를 통해 지도에서 가장 높은 지점들의 위치를 모두 찾아 리스트에 저장합니다.
3.  **DFS + 백트래킹 함수 설계**:
    * `explore_path(r, c, curr_h, path_len, chance)` 라는 재귀 함수를 설계합니다.
    * **인자**: `(r, c)`는 현재 위치, `curr_h`는 현재 칸의 높이, `path_len`은 지금까지의 경로 길이, `chance`는 지형을 깎을 기회가 남았는지 여부(True/False)를 의미합니다.
    * **백트래킹**: 한 경로의 탐색이 끝난 후 다른 경로를 탐색할 때, 이전에 방문했던 칸을 다시 방문할 수 있어야 합니다. 이를 위해 함수 시작 시 `visit[r][c] = 1`로 방문 표시를 하고, 함수가 종료되기 직전 `visit[r][c] = 0`으로 방문 표시를 해제하는 **백트래킹** 기법을 사용합니다.
4.  **탐색 로직 (경우의 수 분기)**:
    * 현재 위치 `(r, c)`에서 상하좌우 4방향의 인접 칸 `(nr, nc)`를 탐색합니다.
    * **Case 1: 기본 이동**: 다음 칸 `(nr, nc)`의 높이가 현재 칸 `curr_h`보다 **낮은 경우**, 경로를 1 증가시켜 DFS를 재귀 호출합니다.
    * **Case 2: 지형 공사**: 다음 칸의 높이가 현재 칸보다 **높거나 같은 경우**, 아래 두 조건을 모두 만족하면 공사를 진행합니다.
        1.  아직 공사 기회(`chance`)를 사용하지 않았다.
        2.  `grid[nr][nc] - (curr_h - 1)` 만큼 깎는 깊이가 `K` 이하이다.
        * 위 조건이 만족되면, 다음 칸의 높이를 `curr_h - 1`로 간주하고 경로를 1 증가시켜 DFS를 재귀 호출합니다. 이때, 공사 기회를 사용했으므로 `chance`를 `False`로 넘겨줍니다.
5.  **최대 길이 갱신**: 더 이상 진행할 수 없는 경로의 끝에 도달하면(함수가 종료되기 직전), 현재까지의 경로 길이 `path_len`을 전역 변수 `max_path_len`과 비교하여 최대값을 갱신합니다.
6.  **실행**: 찾아둔 모든 시작점에 대해 `explore_path` 함수를 각각 호출하여 모든 가능성을 탐색하고, 최종적으로 `max_path_len`에 저장된 값을 출력합니다.

---

## 💻 코드
* [1949.py](1949.py)