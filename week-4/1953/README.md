# 1953. 탈주범 검거

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgvQCv6GNXHBIT9&contestProbId=AV5PpLlKAQ4DFAUq&probBoxId=AZjE2kOaAXDHBIO0&type=PROBLEM&problemBoxTitle=8%EC%9B%94+3-4%EC%A3%BC%EC%B0%A8%288%2F28%EA%B9%8C%EC%A7%80+%ED%91%B8%EC%8B%9C%EC%98%A4%29&problemBoxCnt=4)


## 💡 접근 방식 1: 레벨 순회

### 1. 사용 알고리즘
* **너비 우선 탐색 (BFS) / 레벨 순회 (Level-order Traversal)**
* **시뮬레이션 (Simulation)**
* **구현 (Implementation)**

### 2. 문제 풀이 과정
1.  **시간대별 시뮬레이션**: 문제를 BFS(너비 우선 탐색)의 레벨 순회 방식으로 접근합니다. 즉, 1시간 후에 도달할 수 있는 모든 위치를 찾고, 그 위치들을 기반으로 2시간 후에 도달할 수 있는 위치를 찾는 과정을 L시간이 될 때까지 반복합니다.
2.  **핵심 자료구조 설계**:
    * `tunnels`: 각 터널 타입(1~7)에서 **출발**할 수 있는 방향(상, 하, 좌, 우) 정보를 저장한 딕셔너리입니다.
    * `connected`: 특정 방향으로 이동했을 때, **도착** 지점에 있어야 할 연결 가능한 터널 타입 정보를 저장한 딕셔너리입니다. 이 구조를 통해 터널 간의 양방향 연결성을 효율적으로 검사할 수 있습니다.
    * `one_hour_ago`: 직전 시간에 방문했던 위치들을 저장하는 리스트입니다. 현재 시간에 탐색을 시작할 기준점이 됩니다.
    * `possible`: `L`시간 동안 방문 가능한 모든 위치의 좌표를 중복 없이 저장하기 위한 `set`입니다.
3.  **시뮬레이션 루프**:
    * `after_escape` 변수를 `1`부터 `L`까지 증가시키는 `while` 루프를 실행합니다.
    * **1시간 후**: 시작점 `(R, C)`를 `possible` set에 추가하고, 다음 시간의 탐색 기준점이 될 `one_hour_ago` 리스트에 저장합니다.
    * **2시간 이후**: `one_hour_ago` 리스트에 저장된 모든 위치를 순회하며 탐색을 확장합니다.
4.  **유효성 검사 및 탐색 확장**:
    * `one_hour_ago`의 각 위치 `(x, y)`에서 `tunnels` 딕셔너리를 참고하여 갈 수 있는 모든 방향을 탐색합니다.
    * 다음 위치 `(nx, ny)`에 대해 아래 3가지 조건을 모두 만족하는지 검사합니다.
        1.  지하 터널 지도 범위 안에 있는가?
        2.  `possible` set에 없어 이전에 방문한 적이 없는 새로운 위치인가?
        3.  `connected` 딕셔너리를 통해 `(x, y)` -> `(nx, ny)` 방향으로의 터널이 유효하게 연결되는가?
    * 모든 조건을 만족하는 새로운 위치는 `visited` 리스트(현재 시간에 발견된 위치들)와 `possible` set에 추가합니다.
5.  **상태 갱신 및 종료**:
    * 한 시간에 대한 탐색이 끝나면, `visited` 리스트를 `one_hour_ago`에 복사하여 다음 시간의 탐색 기준으로 삼습니다.
    * `while` 루프가 종료되면 `possible` set의 크기(`len(possible)`)가 최종적으로 탈주범이 있을 수 있는 장소의 총 개수가 됩니다.

---
### 💻 코드
* [1953.py](1953.py)


## 💡 접근 방식 2: BFS

### 1. 사용 알고리즘
* **너비 우선 탐색 (BFS, Breadth-First Search)**
* **그래프 이론 (Graph Theory)**
* **구현 (Implementation)** / **시뮬레이션 (Simulation)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 지하 터널 지도를 노드(정점)로, 터널 구조물에 따라 연결된 파이프를 간선(엣지)으로 가지는 그래프로 간주합니다. 탈주범이 `L`시간 동안 이동할 수 있는 장소의 개수는 시작점 `(R, C)`에서 거리가 `L` 이내인 모든 노드의 개수를 찾는 것과 같습니다.
2.  **BFS 알고리즘 선택**: 시작점으로부터 거리에 따라 순차적으로 탐색을 확장해 나가는 **BFS**가 이 문제에 가장 적합한 알고리즘입니다. BFS의 각 레벨(depth)은 탈출 후 경과한 시간과 같습니다.
3.  **데이터 구조화**: 탐색 효율을 높이기 위해 터널 정보를 미리 구조화합니다.
    * `tunnels`: 각 터널 타입(1~7)에서 나아갈 수 있는 방향(상, 하, 좌, 우)을 저장하는 딕셔너리입니다.
    * `connected`: 특정 방향(예: '상'으로 이동)으로 이동했을 때, 도착 지점에 있어야 할 연결 가능한 터널 타입을 저장하는 딕셔너리입니다. 이를 통해 두 터널이 서로 연결되는지 쉽게 확인할 수 있습니다.
4.  **BFS 탐색 과정**:
    * `visited` 2차원 배열을 생성하여, 각 위치의 방문 여부와 함께 해당 위치에 도달하기까지 경과된 시간(`1`부터 시작)을 기록합니다.
    * 큐(Queue)에 시작 위치 `(R, C)`를 삽입하고, `visited[R][C]`를 `1`로 초기화합니다.
    * 큐에서 위치 `(x, y)`를 꺼내고, 현재 위치에 도달한 시간이 `L`이라면 탐색을 중단합니다. BFS는 레벨 순서대로 탐색하므로, 시간이 `L`인 지점에 도달했다는 것은 `L`시간 이내에 갈 수 있는 모든 곳의 탐색이 완료되었음을 의미합니다.
    * 현재 위치 `(x, y)`의 터널 타입을 `tunnels` 딕셔너리에서 조회하여 이동 가능한 모든 방향을 확인합니다.
    * 각 방향에 대해 다음 위치 `(nx, ny)`가 지도 범위 내에 있고, 아직 방문하지 않았으며(`visited[nx][ny] == 0`), `connected` 딕셔너리를 통해 현재 터널과 다음 터널이 유효하게 연결되는지 검사합니다.
    * 모든 조건을 만족하면, 다음 위치 `(nx, ny)`를 큐에 삽입하고 `visited[nx][ny]`에 현재 시간 + 1을 기록합니다.
5.  **결과 계산**: BFS를 실행하면서 유효한 위치를 큐에 추가할 때마다 카운트를 1씩 증가시킵니다. BFS가 종료된 후의 최종 카운트가 `L` 시간 동안 탈주범이 있을 수 있는 장소의 총 개수가 됩니다.

---

### 💻 코드
* [1953v2.py](1953v2.py)

---

## 💡 오류 분석 및 해결 (Error Analysis & Solution)

### 1. 문제 원인 (Cause of Error)
초기 코드에서는 현재 위치의 터널 모양만을 기준으로 이동 여부를 판단했습니다. 이로 인해 이동하려는 다음 칸의 터널 구조와 연결될 수 없는 경우에도 이동 가능한 것으로 잘못 처리하는 문제가 발생했습니다.

* **오류 예시**: 현재 위치가 **상하좌우가 뚫린 `+` 모양 (타입 1)**이고, 오른쪽 칸이 **상하만 뚫린 `|` 모양 (타입 2)**인 경우.
    * **기존 로직**: 현재 위치(`+`)가 오른쪽으로 갈 수 있으므로 이동 `가능`으로 판단.
    * **실제 상황**: 도착 위치(`|`)는 왼쪽과 연결되어 있지 않으므로 이동 `불가능`.

이처럼 **이동의 유효성을 단방향으로만 검사**하여 발생한 문제였습니다.

---

### 2. 해결 방법 (Solution)
이동의 유효성을 판단할 때, **현재 위치와 도착 위치 양쪽 모두를 확인**하도록 로직을 수정했습니다.

1.  **현재 위치 출발 조건 확인**: 현재 `(x, y)`의 터널이 가려는 방향으로 길이 뚫려 있는지 확인합니다.
2.  **도착 위치 연결 조건 확인**: 도착할 `(nx, ny)`의 터널이 현재 위치에서 오는 방향과 연결되는 구조인지 추가로 확인합니다.

이처럼 **양방향 연결성**을 모두 검사함으로써, 실제로 이동할 수 있는 경로만 탐색하도록 문제를 해결했습니다.